<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/lib.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib.rs" />
              <option name="originalContent" value="#![warn(clippy::all, rust_2018_idioms)]&#10;&#10;use std::sync::OnceLock;&#10;&#10;pub static RT_HANDLE: OnceLock&lt;tokio::runtime::Handle&gt; = OnceLock::new();&#10;&#10;pub fn spawn_task&lt;F&gt;(future: F)&#10;where&#10;    F: std::future::Future&lt;Output = ()&gt; + Send + 'static,&#10;{&#10;    RT_HANDLE.get().unwrap().spawn(future);&#10;}&#10;&#10;pub fn run_terminal_command(command: String) {&#10;    spawn_task(async move {&#10;        let output = tokio::process::Command::new(&quot;sh&quot;)&#10;            .arg(&quot;-c&quot;)&#10;            .arg(&amp;command)&#10;            .output()&#10;            .await;&#10;        match output {&#10;            Ok(output) =&gt; {&#10;                let stdout = String::from_utf8_lossy(&amp;output.stdout);&#10;                let stderr = String::from_utf8_lossy(&amp;output.stderr);&#10;                println!(&quot;Command executed: {}&quot;, command);&#10;                if !stdout.is_empty() {&#10;                    println!(&quot;Output: {}&quot;, stdout);&#10;                }&#10;                if !stderr.is_empty() {&#10;                    eprintln!(&quot;Error: {}&quot;, stderr);&#10;                }&#10;            }&#10;            Err(e) =&gt; eprintln!(&quot;Failed to execute command: {:?}&quot;, e),&#10;        }&#10;    });&#10;}&#10;&#10;pub fn send_event(message: AppMessage) {&#10;    let _ = EVENT_SENDER.get().unwrap().send(message);&#10;}&#10;&#10;pub fn dispatch_folder_event(event: FolderEvent) {&#10;    println!(&quot;Dispatching folder event: {:?}&quot;, event);&#10;    send_event(AppMessage::Event(AppEvent::Folder(event)));&#10;}&#10;&#10;pub fn dispatch_folder_command(command: FolderCommand) {&#10;    println!(&quot;Dispatching folder command: {:?}&quot;, command);&#10;    let wrapped = WrappedFolderCommand {&#10;        command,&#10;        callback: None,&#10;    };&#10;    send_event(AppMessage::Command(AppCommand::Folder(wrapped)));&#10;}&#10;&#10;pub fn dispatch_folder_command_with_callback&lt;F&gt;(command: FolderCommand, callback: Option&lt;F&gt;)&#10;where&#10;    F: Fn() + Send + 'static,&#10;{&#10;    let cb_box = callback.map(|f| Box::new(f) as Box&lt;dyn Fn() + Send + 'static&gt;);&#10;    let wrapped = WrappedFolderCommand {&#10;        command,&#10;        callback: cb_box,&#10;    };&#10;    send_event(AppMessage::Command(AppCommand::Folder(wrapped)));&#10;}&#10;&#10;pub fn with_folder_state&lt;F, R&gt;(f: F) -&gt; R&#10;where&#10;    F: FnOnce(&amp;crate::state::folder_state::FoldersState) -&gt; R,&#10;{&#10;    f(&amp;crate::state::folder_state::FOLDER_STATE)&#10;}&#10;&#10;pub fn with_folder_state_reducer&lt;F, R&gt;(f: F) -&gt; R&#10;where&#10;    F: FnOnce(&amp;crate::state::folder_state::FolderReducer&lt;'static&gt;) -&gt; R,&#10;{&#10;    // FOLDER_STATE is a 'static LazyLock, so we can create a FolderReducer&lt;'static&gt; safely&#10;    let reducer = crate::state::folder_state::FolderReducer {&#10;        state: &amp;crate::state::folder_state::FOLDER_STATE,&#10;    };&#10;    f(&amp;reducer)&#10;}&#10;pub mod app;&#10;pub mod component;&#10;pub mod db;&#10;pub mod domain;&#10;pub mod ext;&#10;pub mod prisma;&#10;pub mod state;&#10;pub static PRISMA_CLIENT: OnceLock&lt;prisma::PrismaClient&gt; = OnceLock::new();&#10;pub use app::App;&#10;&#10;// Event system&#10;use crossbeam::channel::{Receiver, Sender};&#10;&#10;use crate::domain::folder::{&#10;    folder_command_handler::FolderCommand, folder_event_handler::FolderEvent,&#10;};&#10;&#10;// Wrapper for commands that can optionally carry a callback to be executed after handling.&#10;// The callback is optional and boxed; we use `Fn()` for object safety and simplicity.&#10;pub struct WrappedFolderCommand {&#10;    pub command: FolderCommand,&#10;    pub callback: Option&lt;Box&lt;dyn Fn() + Send + 'static&gt;&gt;,&#10;}&#10;&#10;impl std::fmt::Debug for WrappedFolderCommand {&#10;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {&#10;        f.debug_struct(&quot;WrappedFolderCommand&quot;)&#10;            .field(&quot;command&quot;, &amp;self.command)&#10;            .field(&quot;has_callback&quot;, &amp;self.callback.is_some())&#10;            .finish()&#10;    }&#10;}&#10;&#10;// Domain-specific message types&#10;#[derive(Debug)]&#10;pub enum AppCommand {&#10;    Folder(WrappedFolderCommand),&#10;}&#10;&#10;#[derive(Debug)]&#10;pub enum AppEvent {&#10;    Folder(FolderEvent),&#10;}&#10;&#10;#[derive(Debug)]&#10;pub enum AppMessage {&#10;    Command(AppCommand),&#10;    Event(AppEvent),&#10;    Callback(Box&lt;dyn Fn() + Send + 'static&gt;),&#10;}&#10;&#10;pub static EVENT_SENDER: OnceLock&lt;Sender&lt;AppMessage&gt;&gt; = OnceLock::new();&#10;pub static EVENT_RECEIVER: OnceLock&lt;Receiver&lt;AppMessage&gt;&gt; = OnceLock::new();&#10;" />
              <option name="updatedContent" value="#![warn(clippy::all, rust_2018_idioms)]&#10;&#10;use std::sync::OnceLock;&#10;&#10;pub static RT_HANDLE: OnceLock&lt;tokio::runtime::Handle&gt; = OnceLock::new();&#10;&#10;pub fn spawn_task&lt;F&gt;(future: F)&#10;where&#10;    F: std::future::Future&lt;Output = ()&gt; + Send + 'static,&#10;{&#10;    RT_HANDLE.get().unwrap().spawn(future);&#10;}&#10;&#10;pub fn run_terminal_command(command: String) {&#10;    spawn_task(async move {&#10;        let output = tokio::process::Command::new(&quot;sh&quot;)&#10;            .arg(&quot;-c&quot;)&#10;            .arg(&amp;command)&#10;            .output()&#10;            .await;&#10;        match output {&#10;            Ok(output) =&gt; {&#10;                let stdout = String::from_utf8_lossy(&amp;output.stdout);&#10;                let stderr = String::from_utf8_lossy(&amp;output.stderr);&#10;                println!(&quot;Command executed: {}&quot;, command);&#10;                if !stdout.is_empty() {&#10;                    println!(&quot;Output: {}&quot;, stdout);&#10;                }&#10;                if !stderr.is_empty() {&#10;                    eprintln!(&quot;Error: {}&quot;, stderr);&#10;                }&#10;            }&#10;            Err(e) =&gt; eprintln!(&quot;Failed to execute command: {:?}&quot;, e),&#10;        }&#10;    });&#10;}&#10;&#10;pub fn send_event(message: AppMessage) {&#10;    let _ = EVENT_SENDER.get().unwrap().send(message);&#10;}&#10;&#10;pub fn dispatch_folder_event(event: FolderEvent) {&#10;    println!(&quot;Dispatching folder event: {:?}&quot;, event);&#10;    send_event(AppMessage::Event(AppEvent::Folder(event)));&#10;}&#10;&#10;pub fn dispatch_folder_command(command: FolderCommand) {&#10;    println!(&quot;Dispatching folder command: {:?}&quot;, command);&#10;    let wrapped = WrappedFolderCommand {&#10;        command,&#10;        callback: None,&#10;    };&#10;    send_event(AppMessage::Command(AppCommand::Folder(wrapped)));&#10;}&#10;&#10;pub fn dispatch_folder_command_with_callback&lt;F&gt;(command: FolderCommand, callback: Option&lt;F&gt;)&#10;where&#10;    F: Fn() + Send + 'static,&#10;{&#10;    let cb_box = callback.map(|f| Box::new(f) as Box&lt;dyn Fn() + Send + 'static&gt;);&#10;    let wrapped = WrappedFolderCommand {&#10;        command,&#10;        callback: cb_box,&#10;    };&#10;    send_event(AppMessage::Command(AppCommand::Folder(wrapped)));&#10;}&#10;&#10;pub fn with_folder_state&lt;F, R&gt;(f: F) -&gt; R&#10;where&#10;    F: FnOnce(&amp;crate::state::folder_state::FoldersState) -&gt; R,&#10;{&#10;    f(&amp;crate::state::folder_state::FOLDER_STATE)&#10;}&#10;&#10;pub fn with_folder_state_reducer&lt;F, R&gt;(f: F) -&gt; R&#10;where&#10;    F: FnOnce(&amp;crate::state::folder_state::FolderReducer&lt;'static&gt;) -&gt; R,&#10;{&#10;    // FOLDER_STATE is a 'static LazyLock, so we can create a FolderReducer&lt;'static&gt; safely&#10;    let reducer = crate::state::folder_state::FolderReducer {&#10;        state: &amp;crate::state::folder_state::FOLDER_STATE,&#10;    };&#10;    f(&amp;reducer)&#10;}&#10;pub mod app;&#10;pub mod component;&#10;pub mod db;&#10;pub mod domain;&#10;pub mod ext;&#10;pub mod prisma;&#10;pub mod state;&#10;pub static PRISMA_CLIENT: OnceLock&lt;prisma::PrismaClient&gt; = OnceLock::new();&#10;pub use app::App;&#10;&#10;// Event system&#10;use crossbeam::channel::{Receiver, Sender};&#10;&#10;use crate::domain::folder::{&#10;    folder_command_handler::FolderCommand, folder_event_handler::FolderEvent,&#10;};&#10;&#10;// Wrapper for commands that can optionally carry a callback to be executed after handling.&#10;// The callback is optional and boxed; we use `Fn()` for object safety and simplicity.&#10;pub struct WrappedFolderCommand {&#10;    pub command: FolderCommand,&#10;    pub callback: Option&lt;Box&lt;dyn Fn() + Send + 'static&gt;&gt;,&#10;}&#10;&#10;impl std::fmt::Debug for WrappedFolderCommand {&#10;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {&#10;        f.debug_struct(&quot;WrappedFolderCommand&quot;)&#10;            .field(&quot;command&quot;, &amp;self.command)&#10;            .field(&quot;has_callback&quot;, &amp;self.callback.is_some())&#10;            .finish()&#10;    }&#10;}&#10;&#10;// Domain-specific message types&#10;#[derive(Debug)]&#10;pub enum AppCommand {&#10;    Folder(WrappedFolderCommand),&#10;}&#10;&#10;#[derive(Debug)]&#10;pub enum AppEvent {&#10;    Folder(FolderEvent),&#10;}&#10;&#10;pub enum AppMessage {&#10;    Command(AppCommand),&#10;    Event(AppEvent),&#10;    Callback(Box&lt;dyn Fn() + Send + 'static&gt;),&#10;}&#10;&#10;impl std::fmt::Debug for AppMessage {&#10;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {&#10;        match self {&#10;            AppMessage::Command(cmd) =&gt; f.debug_tuple(&quot;Command&quot;).field(cmd).finish(),&#10;            AppMessage::Event(evt) =&gt; f.debug_tuple(&quot;Event&quot;).field(evt).finish(),&#10;            AppMessage::Callback(_) =&gt; f.debug_tuple(&quot;Callback&quot;).field(&amp;&quot;&lt;callback&gt;&quot;).finish(),&#10;        }&#10;    }&#10;}&#10;&#10;pub static EVENT_SENDER: OnceLock&lt;Sender&lt;AppMessage&gt;&gt; = OnceLock::new();&#10;pub static EVENT_RECEIVER: OnceLock&lt;Receiver&lt;AppMessage&gt;&gt; = OnceLock::new();&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>