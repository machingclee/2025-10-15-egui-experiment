<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/BUNDLING_MACOS_APP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BUNDLING_MACOS_APP.md" />
              <option name="originalContent" value="# Bundling Rust Application as macOS .app&#10;&#10;This guide explains how to bundle your Rust egui application into a native macOS application (.app bundle).&#10;&#10;## Why Bundle as .app?&#10;&#10;**Without bundling:**&#10;&#10;- Running `cargo run` opens a terminal window&#10;- Cannot double-click to launch from Finder&#10;- No app icon in Dock&#10;- Not installable like a normal Mac app&#10;&#10;**With .app bundle:**&#10;&#10;- ✅ Double-clickable from Finder&#10;- ✅ Custom app icon&#10;- ✅ No terminal window appears&#10;- ✅ Can be installed to /Applications&#10;- ✅ Looks and behaves like any other Mac app&#10;&#10;## Quick Start&#10;&#10;Simply run the bundling script:&#10;&#10;```bash&#10;./bundle_macos.sh&#10;```&#10;&#10;This will create `Shell Script Manager.app` in your project directory.&#10;&#10;## Developer Testing&#10;&#10;After bundling, macOS Gatekeeper may block the app with a &quot;malware&quot; warning. **For testing/development**, use this&#10;command to bypass the warning:&#10;&#10;```bash&#10;sudo xattr -rd com.apple.quarantine &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;Then double-click the app to launch it normally.&#10;&#10;**Alternative:** Right-click the app → Select &quot;Open&quot; → Click &quot;Open&quot; in the dialog. macOS will remember your choice.&#10;&#10;&gt; **Note:** This is only needed for local development. For distribution to other users, you'll need proper code signing&#10;&gt; with an Apple Developer certificate.&#10;&#10;## How to Use the .app Bundle&#10;&#10;### Option 1: Run from Terminal&#10;&#10;```bash&#10;open &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;### Option 2: Double-click in Finder&#10;&#10;1. Navigate to your project folder in Finder&#10;2. Double-click `Shell Script Manager.app`&#10;3. The app launches without any terminal window!&#10;&#10;### Option 3: Install to Applications&#10;&#10;1. Drag `Shell Script Manager.app` to `/Applications` folder&#10;2. Find it in Launchpad or Applications folder&#10;3. Launch like any other Mac app&#10;&#10;## What the Script Does&#10;&#10;### 1. Build Release Binary&#10;&#10;```bash&#10;cargo build --release&#10;```&#10;&#10;- Compiles your Rust application in optimized release mode&#10;- Creates binary at `target/release/shell_script_manager`&#10;&#10;### 2. Create .app Bundle Structure&#10;&#10;```&#10;Shell Script Manager.app/&#10;├── Contents/&#10;    ├── MacOS/                 # Executable goes here&#10;    │   └── shell_script_manager&#10;    ├── Resources/             # Icons and resources&#10;    │   ├── icon.icns&#10;    │   └── icon.png&#10;    └── Info.plist            # App metadata&#10;```&#10;&#10;### 3. Copy Executable&#10;&#10;- Copies the compiled binary into `Contents/MacOS/`&#10;&#10;### 4. Create App Icon (ICNS format)&#10;&#10;Converts your PNG icons to macOS ICNS format with multiple sizes:&#10;&#10;- 16×16, 32×32 (normal &amp; retina)&#10;- 128×128, 256×256 (normal &amp; retina)&#10;- 512×512, 1024×1024 (normal &amp; retina)&#10;&#10;This ensures the icon looks sharp at all sizes (Dock, Finder, etc.)&#10;&#10;### 5. Create Info.plist&#10;&#10;The metadata file that tells macOS about your app:&#10;&#10;```xml&#10;&#10;&lt;key&gt;CFBundleExecutable&lt;/key&gt;&#10;&lt;string&gt;shell_script_manager&lt;/string&gt;      &lt;!-- Binary to run --&gt;&#10;&#10;&lt;key&gt;CFBundleIconFile&lt;/key&gt;&#10;&lt;string&gt;icon.icns&lt;/string&gt;                 &lt;!-- App icon --&gt;&#10;&#10;&lt;key&gt;CFBundleIdentifier&lt;/key&gt;&#10;&lt;string&gt;com.shellscriptmanager.app&lt;/string&gt; &lt;!-- Unique ID --&gt;&#10;&#10;&lt;key&gt;CFBundleName&lt;/key&gt;&#10;&lt;string&gt;Shell Script Manager&lt;/string&gt;      &lt;!-- Display name --&gt;&#10;&#10;&lt;key&gt;NSHighResolutionCapable&lt;/key&gt;&#10;&lt;true/&gt;                                     &lt;!-- Retina support --&gt;&#10;```&#10;&#10;### 6. Set Executable Permissions&#10;&#10;```bash&#10;chmod +x Contents/MacOS/shell_script_manager&#10;```&#10;&#10;Makes the binary executable so macOS can run it.&#10;&#10;### 7. Code Sign the App Bundle&#10;&#10;```bash&#10;codesign --force --deep --sign - &quot;Shell Script Manager.app&quot;&#10;xattr -cr &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;The script automatically performs **ad-hoc code signing**:&#10;&#10;- `--sign -` uses ad-hoc signing (no developer certificate required)&#10;- Prevents macOS &quot;damaged&quot; or &quot;can't be verified&quot; warnings&#10;- `xattr -cr` removes quarantine attributes that trigger Gatekeeper&#10;- **For personal use only** - distribution requires a Developer ID certificate&#10;&#10;## Customization&#10;&#10;### Change App Name&#10;&#10;Edit `bundle_macos.sh`:&#10;&#10;```bash&#10;APP_NAME=&quot;Your App Name&quot;&#10;BUNDLE_NAME=&quot;Your App Name.app&quot;&#10;```&#10;&#10;### Change Bundle Identifier&#10;&#10;```bash&#10;BUNDLE_ID=&quot;com.yourcompany.yourapp&quot;&#10;```&#10;&#10;### Change Version&#10;&#10;```bash&#10;VERSION=&quot;1.0.0&quot;&#10;```&#10;&#10;### Use Different Icon&#10;&#10;Replace the icon files in the `assets/` folder:&#10;&#10;- `icon-256.png` - 256×256 pixels&#10;- `icon-1024.png` - 1024×1024 pixels&#10;&#10;## Understanding Info.plist Keys&#10;&#10;| Key                          | Description                                           |&#10;|------------------------------|-------------------------------------------------------|&#10;| `CFBundleExecutable`         | Name of the executable file to run                    |&#10;| `CFBundleIconFile`           | Name of the icon file (without extension)             |&#10;| `CFBundleIdentifier`         | Unique reverse-DNS identifier for your app            |&#10;| `CFBundleName`               | Display name shown in Finder and Dock                 |&#10;| `CFBundleVersion`            | Build version number                                  |&#10;| `CFBundleShortVersionString` | User-visible version (e.g., &quot;1.0.0&quot;)                  |&#10;| `LSMinimumSystemVersion`     | Minimum macOS version required                        |&#10;| `NSHighResolutionCapable`    | Support for Retina displays                           |&#10;| `NSPrincipalClass`           | Main application class (NSApplication for Cocoa apps) |&#10;&#10;## Hiding the Terminal Window&#10;&#10;The app is configured to hide the terminal in release mode via `main.rs`:&#10;&#10;```rust&#10;#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]&#10;```&#10;&#10;**Debug mode** (`cargo run`):&#10;&#10;- Terminal visible for debugging output&#10;- Console output (println, eprintln) works&#10;&#10;**Release mode** (.app bundle):&#10;&#10;- No terminal window appears&#10;- Console output is conditional (wrapped in `#[cfg(debug_assertions)]`)&#10;&#10;## Distribution&#10;&#10;### For Personal Use&#10;&#10;Just copy `Shell Script Manager.app` to your Applications folder.&#10;&#10;### For Other Users&#10;&#10;You'll need to:&#10;&#10;1. **Code sign** the app (requires Apple Developer account)&#10;2. **Notarize** the app (for macOS Gatekeeper)&#10;3. Create a DMG installer (optional, but recommended)&#10;&#10;### Basic Code Signing&#10;&#10;```bash&#10;codesign --force --deep --sign &quot;Developer ID Application: Your Name&quot; &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;## Troubleshooting&#10;&#10;### &quot;Malware&quot; or &quot;can't be verified&quot; Warning (Gatekeeper)&#10;&#10;macOS Gatekeeper blocks unsigned apps from unidentified developers. There are several ways to open your app:&#10;&#10;**Method 1: Right-click to Open (Recommended)**&#10;&#10;1. Right-click (or Control+click) on `Shell Script Manager.app`&#10;2. Select **&quot;Open&quot;** from the context menu&#10;3. In the dialog that appears, click **&quot;Open&quot;** again&#10;4. macOS will remember your choice and won't ask again&#10;&#10;**Method 2: Remove Quarantine Attribute**&#10;&#10;```bash&#10;sudo xattr -rd com.apple.quarantine &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;This removes the quarantine flag that triggers Gatekeeper warnings.&#10;&#10;**Method 3: Disable Gatekeeper Temporarily (Not Recommended)**&#10;&#10;```bash&#10;sudo spctl --master-disable&#10;```&#10;&#10;This disables Gatekeeper system-wide. Remember to re-enable it:&#10;&#10;```bash&#10;sudo spctl --master-enable&#10;```&#10;&#10;**Why This Happens:**&#10;&#10;- Ad-hoc code signing (`--sign -`) doesn't use an Apple Developer certificate&#10;- macOS treats it as an &quot;unidentified developer&quot; app&#10;- This is normal for personal development apps&#10;- For distribution, you need a proper Developer ID certificate and notarization&#10;&#10;### App won't open / &quot;damaged&quot; error&#10;&#10;If the app still shows as &quot;damaged&quot;:&#10;&#10;```bash&#10;# Remove all extended attributes&#10;xattr -cr &quot;Shell Script Manager.app&quot;&#10;&#10;# Re-sign the app&#10;codesign --force --deep --sign - &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;Or disable Gatekeeper temporarily:&#10;&#10;```bash&#10;xattr -cr &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;### Icon not showing&#10;&#10;- Ensure `icon.icns` is in `Contents/Resources/`&#10;- Restart Finder: `killall Finder`&#10;- Check Info.plist has `&lt;key&gt;CFBundleIconFile&lt;/key&gt;`&#10;&#10;### App crashes immediately&#10;&#10;- Check the executable has correct permissions: `ls -la &quot;Shell Script Manager.app/Contents/MacOS/&quot;`&#10;- Run from terminal to see error messages: `&quot;Shell Script Manager.app/Contents/MacOS/shell_script_manager&quot;`&#10;&#10;### Database not found&#10;&#10;The app looks for the database in different locations:&#10;&#10;- **Debug**: Current directory (`./database.db`)&#10;- **Release**: `~/Library/Application Support/ShellScriptManager/database.db`&#10;&#10;## Advanced: Automated Bundling&#10;&#10;Add to your `Cargo.toml`:&#10;&#10;```toml&#10;[package.metadata.bundle]&#10;name = &quot;Shell Script Manager&quot;&#10;identifier = &quot;com.shellscriptmanager.app&quot;&#10;icon = [&quot;assets/icon-256.png&quot;, &quot;assets/icon-1024.png&quot;]&#10;version = &quot;0.1.0&quot;&#10;```&#10;&#10;Or use tools like:&#10;&#10;- [`cargo-bundle`](https://github.com/burtonageo/cargo-bundle)&#10;- [`cargo-packager`](https://github.com/crabnebula-dev/cargo-packager)&#10;&#10;## Summary&#10;&#10;The `.app` bundle is just a specially structured folder that macOS recognizes as an application:&#10;&#10;```&#10;YourApp.app/           ← This is the &quot;application&quot;&#10;└── Contents/          ← Required folder&#10;    ├── Info.plist     ← App metadata (required)&#10;    ├── MacOS/         ← Executable folder (required)&#10;    │   └── yourapp    ← Your binary&#10;    └── Resources/     ← Optional resources&#10;        └── icon.icns  ← App icon&#10;```&#10;&#10;When you double-click the `.app`, macOS:&#10;&#10;1. Reads `Info.plist` to get metadata&#10;2. Runs the executable specified in `CFBundleExecutable`&#10;3. Shows the icon from `CFBundleIconFile`&#10;4. Manages it as a normal macOS application&#10;&#10;That's it! Your Rust application is now a native macOS app. &#10;&#10;" />
              <option name="updatedContent" value="# Bundling Rust Application as macOS .app&#10;&#10;This guide explains how to bundle your Rust egui application into a native macOS application (.app bundle).&#10;&#10;## Why Bundle as .app?&#10;&#10;**Without bundling:**&#10;&#10;- Running `cargo run` opens a terminal window&#10;- Cannot double-click to launch from Finder&#10;- No app icon in Dock&#10;- Not installable like a normal Mac app&#10;&#10;**With .app bundle:**&#10;&#10;- ✅ Double-clickable from Finder&#10;- ✅ Custom app icon&#10;- ✅ No terminal window appears&#10;- ✅ Can be installed to /Applications&#10;- ✅ Looks and behaves like any other Mac app&#10;&#10;## Quick Start&#10;&#10;Simply run the bundling script:&#10;&#10;```bash&#10;./bundle_macos.sh&#10;```&#10;&#10;This will create `Shell Script Manager.app` in your project directory.&#10;&#10;## Developer Testing&#10;&#10;After bundling, macOS Gatekeeper may block the app with a &quot;malware&quot; warning. **For testing/development**, use the provided script:&#10;&#10;```bash&#10;./remove_quarantine.sh&#10;```&#10;&#10;Or manually run:&#10;&#10;```bash&#10;sudo xattr -rd com.apple.quarantine &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;Then double-click the app to launch it normally.&#10;&#10;**Alternative:** Right-click the app → Select &quot;Open&quot; → Click &quot;Open&quot; in the dialog. macOS will remember your choice.&#10;&#10;&gt; **Note:** This is only needed for local development. For distribution to other users, you'll need proper code signing&#10;&gt; with an Apple Developer certificate.&#10;&#10;## How to Use the .app Bundle&#10;&#10;### Option 1: Run from Terminal&#10;&#10;```bash&#10;open &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;### Option 2: Double-click in Finder&#10;&#10;1. Navigate to your project folder in Finder&#10;2. Double-click `Shell Script Manager.app`&#10;3. The app launches without any terminal window!&#10;&#10;### Option 3: Install to Applications&#10;&#10;1. Drag `Shell Script Manager.app` to `/Applications` folder&#10;2. Find it in Launchpad or Applications folder&#10;3. Launch like any other Mac app&#10;&#10;## What the Script Does&#10;&#10;### 1. Build Release Binary&#10;&#10;```bash&#10;cargo build --release&#10;```&#10;&#10;- Compiles your Rust application in optimized release mode&#10;- Creates binary at `target/release/shell_script_manager`&#10;&#10;### 2. Create .app Bundle Structure&#10;&#10;```&#10;Shell Script Manager.app/&#10;├── Contents/&#10;    ├── MacOS/                 # Executable goes here&#10;    │   └── shell_script_manager&#10;    ├── Resources/             # Icons and resources&#10;    │   ├── icon.icns&#10;    │   └── icon.png&#10;    └── Info.plist            # App metadata&#10;```&#10;&#10;### 3. Copy Executable&#10;&#10;- Copies the compiled binary into `Contents/MacOS/`&#10;&#10;### 4. Create App Icon (ICNS format)&#10;&#10;Converts your PNG icons to macOS ICNS format with multiple sizes:&#10;&#10;- 16×16, 32×32 (normal &amp; retina)&#10;- 128×128, 256×256 (normal &amp; retina)&#10;- 512×512, 1024×1024 (normal &amp; retina)&#10;&#10;This ensures the icon looks sharp at all sizes (Dock, Finder, etc.)&#10;&#10;### 5. Create Info.plist&#10;&#10;The metadata file that tells macOS about your app:&#10;&#10;```xml&#10;&#10;&lt;key&gt;CFBundleExecutable&lt;/key&gt;&#10;&lt;string&gt;shell_script_manager&lt;/string&gt;      &lt;!-- Binary to run --&gt;&#10;&#10;&lt;key&gt;CFBundleIconFile&lt;/key&gt;&#10;&lt;string&gt;icon.icns&lt;/string&gt;                 &lt;!-- App icon --&gt;&#10;&#10;&lt;key&gt;CFBundleIdentifier&lt;/key&gt;&#10;&lt;string&gt;com.shellscriptmanager.app&lt;/string&gt; &lt;!-- Unique ID --&gt;&#10;&#10;&lt;key&gt;CFBundleName&lt;/key&gt;&#10;&lt;string&gt;Shell Script Manager&lt;/string&gt;      &lt;!-- Display name --&gt;&#10;&#10;&lt;key&gt;NSHighResolutionCapable&lt;/key&gt;&#10;&lt;true/&gt;                                     &lt;!-- Retina support --&gt;&#10;```&#10;&#10;### 6. Set Executable Permissions&#10;&#10;```bash&#10;chmod +x Contents/MacOS/shell_script_manager&#10;```&#10;&#10;Makes the binary executable so macOS can run it.&#10;&#10;### 7. Code Sign the App Bundle&#10;&#10;```bash&#10;codesign --force --deep --sign - &quot;Shell Script Manager.app&quot;&#10;xattr -cr &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;The script automatically performs **ad-hoc code signing**:&#10;&#10;- `--sign -` uses ad-hoc signing (no developer certificate required)&#10;- Prevents macOS &quot;damaged&quot; or &quot;can't be verified&quot; warnings&#10;- `xattr -cr` removes quarantine attributes that trigger Gatekeeper&#10;- **For personal use only** - distribution requires a Developer ID certificate&#10;&#10;## Customization&#10;&#10;### Change App Name&#10;&#10;Edit `bundle_macos.sh`:&#10;&#10;```bash&#10;APP_NAME=&quot;Your App Name&quot;&#10;BUNDLE_NAME=&quot;Your App Name.app&quot;&#10;```&#10;&#10;### Change Bundle Identifier&#10;&#10;```bash&#10;BUNDLE_ID=&quot;com.yourcompany.yourapp&quot;&#10;```&#10;&#10;### Change Version&#10;&#10;```bash&#10;VERSION=&quot;1.0.0&quot;&#10;```&#10;&#10;### Use Different Icon&#10;&#10;Replace the icon files in the `assets/` folder:&#10;&#10;- `icon-256.png` - 256×256 pixels&#10;- `icon-1024.png` - 1024×1024 pixels&#10;&#10;## Understanding Info.plist Keys&#10;&#10;| Key                          | Description                                           |&#10;|------------------------------|-------------------------------------------------------|&#10;| `CFBundleExecutable`         | Name of the executable file to run                    |&#10;| `CFBundleIconFile`           | Name of the icon file (without extension)             |&#10;| `CFBundleIdentifier`         | Unique reverse-DNS identifier for your app            |&#10;| `CFBundleName`               | Display name shown in Finder and Dock                 |&#10;| `CFBundleVersion`            | Build version number                                  |&#10;| `CFBundleShortVersionString` | User-visible version (e.g., &quot;1.0.0&quot;)                  |&#10;| `LSMinimumSystemVersion`     | Minimum macOS version required                        |&#10;| `NSHighResolutionCapable`    | Support for Retina displays                           |&#10;| `NSPrincipalClass`           | Main application class (NSApplication for Cocoa apps) |&#10;&#10;## Hiding the Terminal Window&#10;&#10;The app is configured to hide the terminal in release mode via `main.rs`:&#10;&#10;```rust&#10;#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]&#10;```&#10;&#10;**Debug mode** (`cargo run`):&#10;&#10;- Terminal visible for debugging output&#10;- Console output (println, eprintln) works&#10;&#10;**Release mode** (.app bundle):&#10;&#10;- No terminal window appears&#10;- Console output is conditional (wrapped in `#[cfg(debug_assertions)]`)&#10;&#10;## Distribution&#10;&#10;### For Personal Use&#10;&#10;Just copy `Shell Script Manager.app` to your Applications folder.&#10;&#10;### For Other Users&#10;&#10;You'll need to:&#10;&#10;1. **Code sign** the app (requires Apple Developer account)&#10;2. **Notarize** the app (for macOS Gatekeeper)&#10;3. Create a DMG installer (optional, but recommended)&#10;&#10;### Basic Code Signing&#10;&#10;```bash&#10;codesign --force --deep --sign &quot;Developer ID Application: Your Name&quot; &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;## Troubleshooting&#10;&#10;### &quot;Malware&quot; or &quot;can't be verified&quot; Warning (Gatekeeper)&#10;&#10;macOS Gatekeeper blocks unsigned apps from unidentified developers. There are several ways to open your app:&#10;&#10;**Method 1: Right-click to Open (Recommended)**&#10;&#10;1. Right-click (or Control+click) on `Shell Script Manager.app`&#10;2. Select **&quot;Open&quot;** from the context menu&#10;3. In the dialog that appears, click **&quot;Open&quot;** again&#10;4. macOS will remember your choice and won't ask again&#10;&#10;**Method 2: Remove Quarantine Attribute**&#10;&#10;```bash&#10;sudo xattr -rd com.apple.quarantine &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;This removes the quarantine flag that triggers Gatekeeper warnings.&#10;&#10;**Method 3: Disable Gatekeeper Temporarily (Not Recommended)**&#10;&#10;```bash&#10;sudo spctl --master-disable&#10;```&#10;&#10;This disables Gatekeeper system-wide. Remember to re-enable it:&#10;&#10;```bash&#10;sudo spctl --master-enable&#10;```&#10;&#10;**Why This Happens:**&#10;&#10;- Ad-hoc code signing (`--sign -`) doesn't use an Apple Developer certificate&#10;- macOS treats it as an &quot;unidentified developer&quot; app&#10;- This is normal for personal development apps&#10;- For distribution, you need a proper Developer ID certificate and notarization&#10;&#10;### App won't open / &quot;damaged&quot; error&#10;&#10;If the app still shows as &quot;damaged&quot;:&#10;&#10;```bash&#10;# Remove all extended attributes&#10;xattr -cr &quot;Shell Script Manager.app&quot;&#10;&#10;# Re-sign the app&#10;codesign --force --deep --sign - &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;Or disable Gatekeeper temporarily:&#10;&#10;```bash&#10;xattr -cr &quot;Shell Script Manager.app&quot;&#10;```&#10;&#10;### Icon not showing&#10;&#10;- Ensure `icon.icns` is in `Contents/Resources/`&#10;- Restart Finder: `killall Finder`&#10;- Check Info.plist has `&lt;key&gt;CFBundleIconFile&lt;/key&gt;`&#10;&#10;### App crashes immediately&#10;&#10;- Check the executable has correct permissions: `ls -la &quot;Shell Script Manager.app/Contents/MacOS/&quot;`&#10;- Run from terminal to see error messages: `&quot;Shell Script Manager.app/Contents/MacOS/shell_script_manager&quot;`&#10;&#10;### Database not found&#10;&#10;The app looks for the database in different locations:&#10;&#10;- **Debug**: Current directory (`./database.db`)&#10;- **Release**: `~/Library/Application Support/ShellScriptManager/database.db`&#10;&#10;## Advanced: Automated Bundling&#10;&#10;Add to your `Cargo.toml`:&#10;&#10;```toml&#10;[package.metadata.bundle]&#10;name = &quot;Shell Script Manager&quot;&#10;identifier = &quot;com.shellscriptmanager.app&quot;&#10;icon = [&quot;assets/icon-256.png&quot;, &quot;assets/icon-1024.png&quot;]&#10;version = &quot;0.1.0&quot;&#10;```&#10;&#10;Or use tools like:&#10;&#10;- [`cargo-bundle`](https://github.com/burtonageo/cargo-bundle)&#10;- [`cargo-packager`](https://github.com/crabnebula-dev/cargo-packager)&#10;&#10;## Summary&#10;&#10;The `.app` bundle is just a specially structured folder that macOS recognizes as an application:&#10;&#10;```&#10;YourApp.app/           ← This is the &quot;application&quot;&#10;└── Contents/          ← Required folder&#10;    ├── Info.plist     ← App metadata (required)&#10;    ├── MacOS/         ← Executable folder (required)&#10;    │   └── yourapp    ← Your binary&#10;    └── Resources/     ← Optional resources&#10;        └── icon.icns  ← App icon&#10;```&#10;&#10;When you double-click the `.app`, macOS:&#10;&#10;1. Reads `Info.plist` to get metadata&#10;2. Runs the executable specified in `CFBundleExecutable`&#10;3. Shows the icon from `CFBundleIconFile`&#10;4. Manages it as a normal macOS application&#10;&#10;That's it! Your Rust application is now a native macOS app. &#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib.rs" />
              <option name="originalContent" value="#![warn(clippy::all, rust_2018_idioms)]&#10;&#10;use std::sync::OnceLock;&#10;&#10;pub static RT_HANDLE: OnceLock&lt;tokio::runtime::Handle&gt; = OnceLock::new();&#10;&#10;pub fn spawn_task&lt;F&gt;(future: F)&#10;where&#10;    F: std::future::Future&lt;Output = ()&gt; + Send + 'static,&#10;{&#10;    RT_HANDLE.get().unwrap().spawn(future);&#10;}&#10;&#10;pub fn run_terminal_command(command: String) {&#10;    spawn_task(async move {&#10;        let output = tokio::process::Command::new(&quot;sh&quot;)&#10;            .arg(&quot;-c&quot;)&#10;            .arg(&amp;command)&#10;            .output()&#10;            .await;&#10;        match output {&#10;            Ok(output) =&gt; {&#10;                let stdout = String::from_utf8_lossy(&amp;output.stdout);&#10;                let stderr = String::from_utf8_lossy(&amp;output.stderr);&#10;                println!(&quot;Command executed: {}&quot;, command);&#10;                if !stdout.is_empty() {&#10;                    println!(&quot;Output: {}&quot;, stdout);&#10;                }&#10;                if !stderr.is_empty() {&#10;                    eprintln!(&quot;Error: {}&quot;, stderr);&#10;                }&#10;            }&#10;            Err(e) =&gt; eprintln!(&quot;Failed to execute command: {:?}&quot;, e),&#10;        }&#10;    });&#10;}&#10;&#10;pub fn send_event(message: AppMessage) {&#10;    let _ = EVENT_SENDER.get().unwrap().send(message);&#10;}&#10;&#10;pub fn dispatch_folder_event(event: FolderEvent) {&#10;    println!(&quot;Dispatching folder event: {:?}&quot;, event);&#10;    send_event(AppMessage::Event(AppEvent::Folder(event)));&#10;}&#10;&#10;pub fn dispatch_folder_command(command: FolderCommand) {&#10;    println!(&quot;Dispatching folder command: {:?}&quot;, command);&#10;    let wrapped = WrappedFolderCommand {&#10;        command,&#10;        callback: None,&#10;    };&#10;    send_event(AppMessage::Command(AppCommand::Folder(wrapped)));&#10;}&#10;&#10;pub fn dispatch_folder_command_with_callback&lt;F&gt;(command: FolderCommand, callback: Option&lt;F&gt;)&#10;where&#10;    F: Fn() + Send + 'static,&#10;{&#10;    let cb_box = callback.map(|f| Box::new(f) as Box&lt;dyn Fn() + Send + 'static&gt;);&#10;    let wrapped = WrappedFolderCommand {&#10;        command,&#10;        callback: cb_box,&#10;    };&#10;    send_event(AppMessage::Command(AppCommand::Folder(wrapped)));&#10;}&#10;&#10;pub fn with_folder_state&lt;F, R&gt;(f: F) -&gt; R&#10;where&#10;    F: FnOnce(&amp;crate::state::folder_state::FoldersState) -&gt; R,&#10;{&#10;    f(&amp;crate::state::folder_state::FOLDER_STATE)&#10;}&#10;&#10;pub fn with_folder_state_reducer&lt;F, R&gt;(f: F) -&gt; R&#10;where&#10;    F: FnOnce(&amp;crate::state::folder_state::FolderReducer&lt;'static&gt;) -&gt; R,&#10;{&#10;    // FOLDER_STATE is a 'static LazyLock, so we can create a FolderReducer&lt;'static&gt; safely&#10;    let reducer = crate::state::folder_state::FolderReducer {&#10;        state: &amp;crate::state::folder_state::FOLDER_STATE,&#10;    };&#10;    f(&amp;reducer)&#10;}&#10;pub mod app;&#10;pub mod component;&#10;pub mod db;&#10;pub mod domain;&#10;pub mod ext;&#10;pub mod prisma;&#10;pub mod state;&#10;pub static PRISMA_CLIENT: OnceLock&lt;prisma::PrismaClient&gt; = OnceLock::new();&#10;pub use app::App;&#10;&#10;// Event system&#10;use crossbeam::channel::{Receiver, Sender};&#10;&#10;use crate::domain::folder::{&#10;    folder_command_handler::FolderCommand, folder_event_handler::FolderEvent,&#10;};&#10;&#10;// Wrapper for commands that can optionally carry a callback to be executed after handling.&#10;// The callback is optional and boxed; we use `Fn()` for object safety and simplicity.&#10;pub struct WrappedFolderCommand {&#10;    pub command: FolderCommand,&#10;    pub callback: Option&lt;Box&lt;dyn Fn() + Send + 'static&gt;&gt;,&#10;}&#10;&#10;impl std::fmt::Debug for WrappedFolderCommand {&#10;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {&#10;        f.debug_struct(&quot;WrappedFolderCommand&quot;)&#10;            .field(&quot;command&quot;, &amp;self.command)&#10;            .field(&quot;has_callback&quot;, &amp;self.callback.is_some())&#10;            .finish()&#10;    }&#10;}&#10;&#10;// Domain-specific message types&#10;#[derive(Debug)]&#10;pub enum AppCommand {&#10;    Folder(WrappedFolderCommand),&#10;}&#10;&#10;#[derive(Debug)]&#10;pub enum AppEvent {&#10;    Folder(FolderEvent),&#10;}&#10;&#10;#[derive(Debug)]&#10;pub enum AppMessage {&#10;    Command(AppCommand),&#10;    Event(AppEvent),&#10;    Callback(Box&lt;dyn Fn() + Send + 'static&gt;),&#10;}&#10;&#10;pub static EVENT_SENDER: OnceLock&lt;Sender&lt;AppMessage&gt;&gt; = OnceLock::new();&#10;pub static EVENT_RECEIVER: OnceLock&lt;Receiver&lt;AppMessage&gt;&gt; = OnceLock::new();&#10;" />
              <option name="updatedContent" value="#![warn(clippy::all, rust_2018_idioms)]&#10;&#10;use std::sync::OnceLock;&#10;&#10;pub static RT_HANDLE: OnceLock&lt;tokio::runtime::Handle&gt; = OnceLock::new();&#10;&#10;pub fn spawn_task&lt;F&gt;(future: F)&#10;where&#10;    F: std::future::Future&lt;Output = ()&gt; + Send + 'static,&#10;{&#10;    RT_HANDLE.get().unwrap().spawn(future);&#10;}&#10;&#10;pub fn run_terminal_command(command: String) {&#10;    spawn_task(async move {&#10;        let output = tokio::process::Command::new(&quot;sh&quot;)&#10;            .arg(&quot;-c&quot;)&#10;            .arg(&amp;command)&#10;            .output()&#10;            .await;&#10;        match output {&#10;            Ok(output) =&gt; {&#10;                let stdout = String::from_utf8_lossy(&amp;output.stdout);&#10;                let stderr = String::from_utf8_lossy(&amp;output.stderr);&#10;                println!(&quot;Command executed: {}&quot;, command);&#10;                if !stdout.is_empty() {&#10;                    println!(&quot;Output: {}&quot;, stdout);&#10;                }&#10;                if !stderr.is_empty() {&#10;                    eprintln!(&quot;Error: {}&quot;, stderr);&#10;                }&#10;            }&#10;            Err(e) =&gt; eprintln!(&quot;Failed to execute command: {:?}&quot;, e),&#10;        }&#10;    });&#10;}&#10;&#10;pub fn send_event(message: AppMessage) {&#10;    let _ = EVENT_SENDER.get().unwrap().send(message);&#10;}&#10;&#10;pub fn dispatch_folder_event(event: FolderEvent) {&#10;    println!(&quot;Dispatching folder event: {:?}&quot;, event);&#10;    send_event(AppMessage::Event(AppEvent::Folder(event)));&#10;}&#10;&#10;pub fn dispatch_folder_command(command: FolderCommand) {&#10;    println!(&quot;Dispatching folder command: {:?}&quot;, command);&#10;    let wrapped = WrappedFolderCommand {&#10;        command,&#10;        callback: None,&#10;    };&#10;    send_event(AppMessage::Command(AppCommand::Folder(wrapped)));&#10;}&#10;&#10;pub fn dispatch_folder_command_with_callback&lt;F&gt;(command: FolderCommand, callback: Option&lt;F&gt;)&#10;where&#10;    F: Fn() + Send + 'static,&#10;{&#10;    let cb_box = callback.map(|f| Box::new(f) as Box&lt;dyn Fn() + Send + 'static&gt;);&#10;    let wrapped = WrappedFolderCommand {&#10;        command,&#10;        callback: cb_box,&#10;    };&#10;    send_event(AppMessage::Command(AppCommand::Folder(wrapped)));&#10;}&#10;&#10;pub fn with_folder_state&lt;F, R&gt;(f: F) -&gt; R&#10;where&#10;    F: FnOnce(&amp;crate::state::folder_state::FoldersState) -&gt; R,&#10;{&#10;    f(&amp;crate::state::folder_state::FOLDER_STATE)&#10;}&#10;&#10;pub fn with_folder_state_reducer&lt;F, R&gt;(f: F) -&gt; R&#10;where&#10;    F: FnOnce(&amp;crate::state::folder_state::FolderReducer&lt;'static&gt;) -&gt; R,&#10;{&#10;    // FOLDER_STATE is a 'static LazyLock, so we can create a FolderReducer&lt;'static&gt; safely&#10;    let reducer = crate::state::folder_state::FolderReducer {&#10;        state: &amp;crate::state::folder_state::FOLDER_STATE,&#10;    };&#10;    f(&amp;reducer)&#10;}&#10;pub mod app;&#10;pub mod component;&#10;pub mod db;&#10;pub mod domain;&#10;pub mod ext;&#10;pub mod prisma;&#10;pub mod state;&#10;pub static PRISMA_CLIENT: OnceLock&lt;prisma::PrismaClient&gt; = OnceLock::new();&#10;pub use app::App;&#10;&#10;// Event system&#10;use crossbeam::channel::{Receiver, Sender};&#10;&#10;use crate::domain::folder::{&#10;    folder_command_handler::FolderCommand, folder_event_handler::FolderEvent,&#10;};&#10;&#10;// Wrapper for commands that can optionally carry a callback to be executed after handling.&#10;// The callback is optional and boxed; we use `Fn()` for object safety and simplicity.&#10;pub struct WrappedFolderCommand {&#10;    pub command: FolderCommand,&#10;    pub callback: Option&lt;Box&lt;dyn Fn() + Send + 'static&gt;&gt;,&#10;}&#10;&#10;impl std::fmt::Debug for WrappedFolderCommand {&#10;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {&#10;        f.debug_struct(&quot;WrappedFolderCommand&quot;)&#10;            .field(&quot;command&quot;, &amp;self.command)&#10;            .field(&quot;has_callback&quot;, &amp;self.callback.is_some())&#10;            .finish()&#10;    }&#10;}&#10;&#10;// Domain-specific message types&#10;#[derive(Debug)]&#10;pub enum AppCommand {&#10;    Folder(WrappedFolderCommand),&#10;}&#10;&#10;#[derive(Debug)]&#10;pub enum AppEvent {&#10;    Folder(FolderEvent),&#10;}&#10;&#10;pub enum AppMessage {&#10;    Command(AppCommand),&#10;    Event(AppEvent),&#10;    Callback(Box&lt;dyn Fn() + Send + 'static&gt;),&#10;}&#10;&#10;impl std::fmt::Debug for AppMessage {&#10;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {&#10;        match self {&#10;            AppMessage::Command(cmd) =&gt; f.debug_tuple(&quot;Command&quot;).field(cmd).finish(),&#10;            AppMessage::Event(evt) =&gt; f.debug_tuple(&quot;Event&quot;).field(evt).finish(),&#10;            AppMessage::Callback(_) =&gt; f.debug_tuple(&quot;Callback&quot;).field(&amp;&quot;&lt;callback&gt;&quot;).finish(),&#10;        }&#10;    }&#10;}&#10;&#10;pub static EVENT_SENDER: OnceLock&lt;Sender&lt;AppMessage&gt;&gt; = OnceLock::new();&#10;pub static EVENT_RECEIVER: OnceLock&lt;Receiver&lt;AppMessage&gt;&gt; = OnceLock::new();&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>